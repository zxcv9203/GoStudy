# 공백 식별자

공백 식별자 "`_`"는 무엇이든 할당할 수 있지만, 읽을 수는 없는 특수 식별자입니다. 

예를 들어 반환 값이 두개있는 함수 foo를 호출하여 값을 받아올 때 다음과 같이 사용할 수 있습니다.

```go
a, _ = foo()
```

함수의 호출의 결과를 버린다고 이해할 수 있습니다. 이 경우 첫번째 반환 값만 관심이 있고 두번째 값에는 관심이 없기에 두번째 반환 값에 대해서는 공백 식별자를 통해 버리게 되는 것입니다. 

물론 이를 별도의 변수를 생성하여 사용하지 않는 형태로 정의한다고 생각할 수 있겠지만, go에서는 일반적이지 않을 뿐만 아니라 애초에 사용하지 않는 변수를 선언하는 것은 컴파일 에러입니다.

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
    fmt.Printf("%s does not exist\n", path)
}

## err vs _

Go의 함수를 호출하는 과정에서는 대부분이 error를 별도로 반환합니다.



이를 공백 식별자로 무시하는 것도 가능은 하겠지만, 이는 매우 나쁜 관행으로 항상 에러가 발생하는 지를 error 변수로 확인해주는 것이 좋은 습관입니다.

// Bad! 파일의 경로가 존재하지 않는다면 문제가 생깁니다.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
```

## 사용하지 않는 패키지와 변수

패키지를 임포트하거나 변수를 선언해놓고 사용하지 않는다면 에러가 발생합니다. 사용하지 않는 임포트는 프로그램의 크기를 불필요하게 부풀리며 컴파일 속도도 저하시킵니다. 코드를 작성하는 개발자 입장에서도 프로그램 개발 중에 존재할 미사용 임포트와 변수들이 계속해서 발생하고, 단지 컴파일이 정상적으로 진행되기 위해 나중에 다시 필요할지도 모를 변수들을 지워나가는 것은 꽤나 신경쓸 일이 많이 생길 수도 있습니다.

공백 식별자는 이러한 우려들에 대한 대안을 제공합니다.

아래의 코드에는 사용되지 않는 패키지와 변수가 import 되는 상황을 예로 들고 있습니다. 
```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
}
```

이 경우에는 당연히 컴파일이 불가한 상황입니다. 같은 코드에서 실제로 패키지를 사용하지는 않지만 공백 식별자를 통해 임시로 컴파일이 가능하게 변환할 수 있습니다. 주로 코드를 작성하는 중간에 이러한 작업들을 수행하게 됩니다.

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf // For debugging; delete when done.
var _ io.Reader    // For debugging; delete when done.

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
    _ = fd
}
```
코드 규약에 따르면 임포트 에러를 잠재우기 위한 전역 변수의 선언은 임포트 구문 바로 다음에 위치해야 하며, 주석을 달아줘야 합니다. 주석을 추가함으로써 코드를 이후 정리해야 한다는 것을 쉽게 떠올릴 수 있게 함과 동시에 이를 쉽게 찾을 수 있게 해줍니다.

## 부수 효과를 위한 패키지 임포트

앞선 설명에서 `fmt`나 `io` 같은 미사용 임포트는 컴파일을 위해 결국 사용을 하거나 사용을 하지 않는다면 제거해야 한다. 그러나 직접 사용을 하지 않더라도, 패키지를 임포트하면서 발생하는 부수 효과를 위해 패키지를 가져오기도 한다.

예를 들어 `net/http/pprof`라는 패키지는 패키지의 초기화 함수를 실행하는 동안 디버깅 정보를 제공하는 `HTTP` 핸들러를 등록한다. 대다수의 클라이언트는 해당 패키지에서 제공하는 별도의 API가 아닌 오직 핸들러 등록만이 필요한 경우가 많은데, 이처럼 부수효과만을 위해 이 패키지를 임포트 하기 위해선 패키지 이름을 공백 식별자로 바꾸면 된다.

```go
import _ "net/http/pprof"
```