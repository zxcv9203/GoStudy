# 포맷팅 (Formatting)

## Go에서의 Formatting

Go에서는 하나의 통일된 소스 코드 포맷을 권장한다.

물론, 컴파일 기반 언어이기에 유효한 코드가 포맷이 잘못되었다고, 당장 빌드 자체가 문제가 되진 않는다.

그럼에도 Go는 다음과 같은 특징을 목표로 한 언어기에 포맷팅이 반드시 필요하다.

이때, 하나의 통일된 포맷으로 소스코드를 포맷팅 해주는 툴이 [gofmt](https://pkg.go.dev/cmd/gofmt)이다.

Go 언어에서 gofmt를 사용하는 이유를 들자면 다음과 같다.

1. 쓰기 쉬워야 한다.
* 코드를 작성할 때, 사소한 서식 문제에서 자유로워야 한다.
2. 읽기 쉬워야 한다.
* 모든 사람의 소스 코드 포맷이 같다면, 다른 사람의 코드 포맷 스타일을 이해하기 위해 별도의 노력을 기울지 않고, 코드 자체에 온전히 집중할 수 있다.
3. 논쟁의 여지가 없어야 한다.
* 들여쓰기, 줄 간격에 대한 논쟁에서부터 자유로워야만 한다.
> 42의 [Norm](https://github.com/42School/norminette)를 go에서 사용한다고 보면 된다. (편의성은 비교가 안되지만 ...)

명시적으로 gofmt 명령어를 사용할 일은 당장 많지 않을 것 같다. go를 지원하는 대부분의 텍스트 에디터(vim, emacs, vscode, goland)에서는 소스 코드를 저장할때 자동으로 gofmt 스타일로 정돈해주는 플러그인을 지원하기에 사용자가 굳이 나서서 명령어를 다뤄야할 상황이 많을까 싶기도 하다.

vscode의 경우, go 플러그인을 설치하고 JSON 파일에 다음을 추가해주면 된다.
```JSON
"[go]": 
{
	"editor.formatOnSave": true
}
```
----
## gofmt 사용법
명시적으로 gofmt를 사용할 때의 사용방법을 작성해보았다.
<br/>
<br/>
```
gofmt [플래그] [경로 ...]
```
아무런 flag를 쓰지 않는다면, gofmt는 포맷팅 결과를 stdout으로 내보낸다. 명시적 경로가 없다면 stdin을 받기위해 대기한다. (파일이 아니라, 소스 코드 자체를 받기 위해 대기한다. stdin이므로 EOF로 입력 종료) 파일이 아니라 경로라면, 하위 파일에 대해 재귀적으로 동작한다.
```JSON
// gofmt flags

-d
		gofmt를 수행했을 때와의 차이를 stdout으로 내보낸다.
-e
		모든 오류를 출력한다.
-l
		go 포맷에 부합하지 않는 파일들을 나열한다.

-r rule
		reformatting을 적용하기 전에 재작성 규칙을 적용한다. 유효한 Go expression에 한정되어 수행가능하며, 패턴에서(-r 뒤의) 단일 소문자 식별자 (ex. a)는 임의의 하위 표현식과 일치하는 와일드 카드 역할을 한다. 

-s
		코드를 단순화한다. (-r 규칙이 있는 경우, -r을 적용한 이후)

-w
		포맷팅 결과를 stdout으로 내보내지 않는다.
		gofmt로 포맷팅한 결과와 다르다면, 원래의 파일에 gofmt로 변환한 소스코드를 덮어쓰기 한다. 덮어쓰기 과정에서 오류가 발생한다면 기존의 파일이 자동 백업으로부터 복원된다.

// 디버깅 관련 옵션
-cpuprofile [파일명]
		지정된 파일에 CPU profile을 작성한다.
```
----
### 사용 예시

1. 불필요한 괄호가 존재하는 파일 나열
```
gofmt -r '(a) -> a' -l *.go
```

2. 불필요한 괄호 제거
```
gofmt -r '(a) -> a' -w *.go
```

3. explicit upper bound -> implicit upper bound
```
gofmt -r 'α[β:len(α)] -> α[β:]' -w [$GOROOT/src]
```

4. 단순화 명령 `-s`
```
[]T{T{}, T{}} 형식의 배열, 슬라이스 또는 맵 합성 리터럴: 
	[]T{T{}, T{}}					->		[]T{{}, {}} 

다음 형식의 슬라이스 표현식: 
	s[a :len(s)] 					-> 		s[a:] 

형식의 범위: 
	1) for x, _ = range v {...}		->		for x = range v {...} 
	2) for _ = range v {...} 		->		for range v {...}
```