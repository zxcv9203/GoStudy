# Go 소개

> Go 란?

Go는 **간단**하고 **안정적**이며 **효율**적인 소프트웨어를 쉽게 구축할 수 있는 오픈소스 프로그래밍 언어입니다.

> Go의 역사

Go는 2007년 9월 21일 로버트 그리즈머, 롭 파이크, 켄 톰슨이 [인페르노](https://en.wikipedia.org/wiki/Inferno_(operating_system))라는 분산 운영체제와 관련된 작업을 하다가 화이트 보드에 새로운 언어에 대한 스케치를 하면서 구상되었다고 합니다.

구글의 직원들은 업무시간 중 20%를 파트타임 프로젝트라고 주요 업무와는 무관한 별도의 다른 프로젝트를 수행할 수 있는 제도가 있는데 Go언어는 이 제도로 만들어진 대표적인 프로젝트입니다.

2008년 1월, 켄 톰슨이 Go 스펙으로 만들어진 코드를 C 코드로 변환하는 컴파일러를 만들기 시작했고, 2008년 중반에는 구글의 공식적인 풀타임 프로젝트로 승격되었습니다.

2008년 5월 이안 테일러는 Go 스펙의 초안을 이용해서 GCC 프론트엔드를 만들기 시작했고, 2008년 말 러스 콕스가 참여하면서 프로토타입에서 실질적인 언어와 응용 프로그램을 쉽게 만들 수 있도록 도와줄 기본적인 라이브러리들이 만들어지기 시작했습니다.

2009년 11월 10일에 리눅스와 Mac OS X에서 동작하는 최초의 버전이 공식발표 되었으며, 출시 직후에는 실용성이 떨어진다는 평가도 있었지만 반년정도 지난 뒤에는 구글 내부에서 실제로 사용되고 있다고 알려지기도 했습니다.

Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해서 구글의 엔지니어 로버트 그리즈머, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었습니다.

- 정적 타이핑 및 대형 시스템으로의 규모로 사용이 가능해야 합니다. (자바와 C++처럼)
- 너무 많은 필수적인 키워드와 반복 없이도 생산적이고 가독성이 좋아야합니다.
- 통합 개발 환경이 필요하지 않지만 지원도 가능해야 합니다.
- 네트워킹 및 다중 처리를 지원해야 합니다.

나중의 인터뷰에서, 언어 설계자 3명이 모두 c++의 복잡성을 싫어하며 이로 인해 새로운 언어를 설계하는 계기가 되었다고 합니다.

Go 1.0은 2012년 3월 출시되었습니다.

> Go를 써야하는 이유

개발자들은 Go를 개발하면서 **간단하고 간결한 직관적인 언어**를 지향하며 C언어 기반으로 `C++` `JAVA` `Python` 의 장점을 뽑아 개발되었습니다.

- Go는 객체지향 프로그래밍(OOP)를 지원하는데 객체지향 프로그래밍에서 사용되는 클래스, 객체, 상속의 개념이 없습니다. 그리고 Go에서 쓰이는 키워드는 Java의 절반 수준인 25개밖에 되지 않습니다.
- Go는 컴파일 언어이지만 컴파일러의 컴파일 속도가 매우 빠르기 때문에 인터프리터 언어(ex : Python)처럼 쓸 수 있습니다.
  물론 컴파일 언어이기 때문에 인터프리터 언어보다는 빠르지 않지만 인터프리터 언어 이상의 성능을 감안했을 때, 굉장히 큰 효율을 보여줍니다.
- Go언어는 단일 파일로 떨어지는 실행 결과물을 장비에 따로 설치하는 것이 없어 외부 의존성에 대한 버전을 신경되지 않아도 돼서 실행이 쉽습니다.
  물론 컴파일 언어이기 때문에 타겟 장비에 맞도록 **크로스 컴파일**을 해야합니다.
  각 장비에 맞는 단일 실행 파일만 있으면 어디서든 동작해 개발자를 위한 개발툴을 만들 때 좋습니다.
- Go언어는 코드가 굉장히 간결합니다. 따라서 코드량 자체가 줄어들고 가독성이 좋습니다. 때문에 후에 유지 관리를 하는게 쉽습니다.
- Go언어는 내장 라이브러리가 굉장히 탄탄합니다. 추가 라이브러리나 프레임 워크 없이도 http 서버도 쉽게 만들 수 있습니다.
- 자바같은 경우 thread 개수가 성능과 직결되어 항상 신경써야 했는데, Go언어에서 사용하는 고루틴 같은 경우에는 엄청나게 많은 수를 사용해도 괜찮아서 코드를 작성하는데 부담이 없습니다.

> Go의 특징

Go는 정적 타입 컴파일 언어의 효율성과 동적 언어처럼 쉬운 프로그래밍을 할 수 있는 것을 목표로 합니다.

Go는 대표적으로 다음과 같은 특징들이 있습니다.

- 자료형이 정적 타입입니다. (자료형에 타입이 다 정해져있습니다.)
- 자료형 변환(타입 캐스팅)이 항상 명시되어야 합니다.
- 가비지 컬렉션 : C언어 같은 경우 메모리를 할당하면 반드시 해제하는 과정이 필요하지만 Go의 경우 가비지 컬렉션을 지원하여 해당 과정이 필요없습니다.
  결과물에 go runtime이 내장되는데 go runtime이 메모리를 핸들링합니다.
- 안정성 : 타입 안전성(강타입)과 메모리 안정성(가비지 컬렉터)
- 병행성 : thread를 한 단계 더 추상화한 **고루틴**이라는 개념을 사용합니다.
- 컴파일 언어 : 인터프린터언어는 아니지만 그의 근접한 수준의 빠른 컴파일
- 포인터는 존재하지만 포인터 연산은 없습니다.

등등이 존재합니다.

Go언어에는 아래와 같이 존재하지 않는 것도 있습니다.

- 클래스
- 상속
- 생성자
- final

> Go의 문법

Go의 문법은 대체로 C와 비슷합니다.

코드 블록들은 중괄호로 둘러싸고 `for` `switch` `if` 를 포함한 일반적인 제어 구조를 가지고 있습니다.

하지만 C와는 다르게, 한 라인의 세미콜론은 필수가 아닌 옵션입니다.

변수 선언은 다르게 작성되고 대개 옵션입니다.

형변환은 명시적으로 해야합니다.

병행성 프로그래밍을 다루기 위해 `go` 와 `select` 키워드가 사용됩니다.

새로운 타입은 `map` ,  유티코드 문자열, 배열 `slice` , 그리고 내부 쓰레드 통신을 위한 `channel` 이 있습니다.

Go는 그리 좋지 않은 하드웨어에서도 빠르게 컴파일 될 수 있도록 디자인 되었습니다.

Go는 가비지 컬렉션 기능이 있는 언어입니다.

병행성(concurrency)와 관련된 Go의 구조적인 규칙들(channel과 선택적인 channel input들)은 Tony Hoare의 [CSP(Communicating Sequential Process)](https://en.wikipedia.org/wiki/Communicating_sequential_processes)로 부터 가져온 것 입니다.

위에 언급한 것처럼 C++이나 Java에 있는 기능들 중 타입 상속, 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않습니다. 해당 기능들은 급하지 않지만 어느 시점에는 기능이 들어갈 거라고 합니다.

> 병행성

Go를 이용해 프로그램들이 서로 소통하면서 상태를 공유하는 동시성(concurrency) 프로그램을 쉽게 만들 수 있습니다.

동시성이란 멀티 쓰레딩, 병렬 컴퓨팅 뿐 아니라, 비 동기성 입출력 또한 포함입니다. 예를 들어, 이벤트 기반 서버와 같이 데이터 베이스나 네트워크 작업과 같이 시간이 많이 걸리는 연산을 하는 동안 프로그램이 다른일을 하는 것을 말합니다.

다음 예제코드는 시간안에 입력을 받고 입력받은 내용을 출력하는 프로그램입니다. 만약 지정된 시간안에 입력이 들어오지 않으면 timeout을 출력하고 종료합니다.

```go
package main

import (
    "fmt"
    "time"
)

func readword(ch chan string) {
    fmt.Println("Type a word, then hit Enter.")
    var word string
    fmt.Scanf("%s", &word)
    ch <- word
}

func timeout(t chan bool) {
    time.Sleep(5 * time.Second)
    t <- true
}

func main() {
    t := make(chan bool)
    go timeout(t)

    ch := make(chan string)
    go readword(ch)

    select {
    case word := <-ch:
        fmt.Println("Received", word)
    case <-t:
        fmt.Println("Timeout.")
    }
}
```

> Go 사용 오픈 소스 프로젝트

- Docker (도커)

  도커는 리눅스의 응용 프로그램들을 프로세스 격리 기술들을 통해 컨테이너로 실행하고 관리하는 오픈소스 프로젝트입니다.

- Kubernetes (쿠버네티스)

  컨테이너화된 애플리케이션의 자동 배포, 스케일링 등을 제공하는 컨테이너 오케스트레이션 도구로, 오픈소스 기반입니다.

- Fedora CoreOS (페도라 코어OS)

  자동으로 최신화되며, 컨테이너화된 워크로드를 안전하고 대규모에서 구동하기 위한 운영체제입니다.

- InfluxDB (인플럭스 DB)

  인플럭스 데이터가 개발한 오픈소스 시계열 데이터베이스로, 운영 모니터링과 애플리케이션 메트릭스, 사물인터넷 센서 데이터, 실시간 분석 등의 분야에서 시계열 데이터의 빠른속도의 고가용성 저장 및 검색에 최적화되어 있습니다.

- Istio (이스티오)

  조직에서 분산형 마이크로 서비스 기반 앱을 어디서나 실행할 수 있도록 지원하는 오픈소스 서비스 메시입니다.

- Traefik (트래픽)
  마이크로 서비스를 쉽고 편리하게 배포할 수 있는 HTTP reverse-proxy 이자 Load-Balancer 입니다.
- Hugo (휴고)

  Go로 작성된 정적 사이트 생성기입니다.

- Terraform (테라폼)
  하시코프에서 오픈소스로 개발중인 클라우드 인프라스트럭처 자동화를 지향하는 코드로서의 인프라스트럭처(IaC) 도구입니다.
- CockroachDB (코크로치 DB)
  cockroach Labs에서 개발한 상업용 분산 SQL 데이터베이스 관리 시스템입니다.
- Teleport (텔레포트)
  SSH, Kubernetes 및 HTTPS를 사용하여 서버 및 클라우드 애플리케이션에 대한 제로 트러스트 액세스를 제공하기 위한 오픈소스 도구입니다.

> Go VS Rust

Go를 사용하는 데 이점

- 빠른 개발 주기
- 높은 실행 속도
- 가비지 수집을 통한 메모리 안정성(원할 경우 수동 메모리 관리도 가능)
- 개발자 편의성
- 단순명료한 코드

러스트를 사용하는 데 이점

- 런타임 정확도(일반적인 실수가 있을 때 컴파일이 되지 않음)
- 최상급 실행 속도
- 가비지 컬렉터 없는 메모리 안정성
- 하드웨어 수준 코드

→ 절대 적인 성능은 Rust가 뛰어나지만 Go는 개발자가 사용하기 쉽기에 유지관리에 더 뛰어나다.

[https://www.itworld.co.kr/howto/186713](https://www.itworld.co.kr/howto/186713)

[https://trio.dev/blog/golang-vs-rust](https://trio.dev/blog/golang-vs-rust)

> Go VS Python

Go같은 경우 파이썬보다 실행 속도가 매우 뛰어나지만 Python 같은 경우 지원되는 라이브러리와 생산 속도가 더 빠릅니다.

[https://daystudy.tistory.com/799](https://daystudy.tistory.com/799)

[https://www.guru99.com/python-vs-go.html](https://www.guru99.com/python-vs-go.html)

[https://ichi.pro/ko/golang-i-god-python-eul-daechehalkkayo-274032057385762](https://ichi.pro/ko/golang-i-god-python-eul-daechehalkkayo-274032057385762)