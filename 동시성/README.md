# 동시성 (Concurrency)

Golang의 동시성을 설명하기 전에 병렬성과 동시성의 개념을 잠깐 짚고 넘어가고자 합니다.
Golang에서는 동시성(concurrency)과 병렬성(parallelism) 기능을 모두 제공하고 있습니다.

기본적인 차이점을 이해하고 넘어가봅시다.

## 동시성 (Concurrency)
![](https://miro.medium.com/max/700/1*7A6X8zAHGy-sPCv7MIVEYA.png)

동시성은 애플리케이션이 동시에 수행해야할 작업이 둘 이상이 있음을 의미합니다. 독립적으로 실행되는 여러 프로세스를 만드는 것입니다.

응용 프로그램은 의도한 동작을 수행하기 위해 많은 프로세스를 함께 처리할 수 있습니다.

간단한 전자 상거래 웹 사이트를 가정하고 이를 실행해야하는 동시 작업 목록으로 예를 들어보겠습니다.

1. 가장 최근에 이뤄진 거래 목록 및 제품과 함께 상단에 배너를 실행합니다.
2. 웹사이트의 현재 온라인 사용자 수를 표시합니다.
3. 제품이 선택되면 사용자 장바구니 세부정보를 업데이트합니다.
4. 남은 할인 시간 등에 대한 시간 카운터를 유지합니다.

전자 상거래 웹 사이트는 고객이 응용 프로그램에 계속 참여하도록 유도해야한다.

해당 웹사이트를 사용자에게 더욱 매력적으로 만들고 이로 인한 더 많은 비즈니스를 유도하려면 앞서 나열한 모든 작업을 동시에 실행해야 합니다.

따라서 이러한 애플리케이션/웹 사이트는 비즈니스 요구 사항을 충족하기 위해 백그라운드에서 실행되는 여러 작업들이 모인 집합으로 표현됩니다.

## 동시(Concurrent) 실행 vs  병렬(Parallel) 실행
![](https://miro.medium.com/max/700/1*5d5udhM4ioJ99o4kCBW8Ow.png)

## 동시 어플리케이션 작업

여러 작업을 수행해야하지만 특정 시점에 사용가능한 단일 코어에서 단 하나의 작업만 실행할 수 있다고 가정해봅시다.

동시 실행 모델에는 작업 간에 Context 전환이 있습니다. 따라서 응용 프로그램은 여러 작업을 처리하지만 실행 코어가 하나만 존재하므로 여러 작업을 같은 시점에 함께 실행하지는 않습니다.

작업 간에 Context 전환이 너무 빨라 작업이 동시에 실행되는 것처럼 느껴집니다. 실제로는 모두 다른 시점에 진행되는 작업들입니다.

위의 그림에서 Concurrency에는 동시에 실행해야 하는 두 가지 작업이 존재합니다. 어느 순깐에든 하나의 작업만 실행 중이며 작업 간에 지속적인 전환이 이뤄지고 있습니다.

## 애플리케이션에 병렬 처리 추가

단일 코어로 작업하는 경우 리소스 제약이 있습니다. 시스템에 더 많은 코어를 추가하면 응용 프로그램에 더 많은 리소스가 제공되고 여러 작업을 다른 코어에서 동시에 실행할 수 있습니다.

위의 그림에는 어느 순간에든 함께 실행되는 두 개의 작업이 있습니다. 작업은 서로 다른 코어에서 병렬로 실행됩니다.

즉, 그림에 표시되어 있듯 동시성은 많은 양의 작업을 한 번에 다루는 것에 대한 개념이고, 병렬성은 한 번에 여러 작업을 처리하는 것에 대한 개념입니다.

Golang으로 작업하는 동안 동시 실행에서 병렬 실행으로 어플리케이션을 쉽게 확장할 수 있습니다. 때문에 Golang은 확장이 용이하다라고 할 수 있습니다.

## 고루틴으로 작업하기

Golang에서 동시성과 병렬 처리를 달성하기 위해, 고루틴의 개념을 이해할 필요가 있습니다. 고루틴을 짧게 정의하자면 스레드 상단에 위치한 Golang의 Wrapper입니다. 즉, 운영 체재가 아닌 Go의 런타임에서 관리합니다.

Go 런타임은 고루틴으로부터 메모리 리소스를 할당하거나 다시 회수해야할 책임이 있습니다. 고루틴은 여러 작업을 수행하는 쓰레드와 비슷하지만, OS의 쓰레드와는 엄연히 다른 개념이며 고루틴은 실제 OS의 쓰레드보다 적은 리소스를 사용합니다.

![](https://miro.medium.com/max/700/1*7hOZoOyWkP9iLNZs-iqNeQ.png)

앞선 동시성을 설명하면서 보았듯 애플리케이션은 여러 개의 동시 작업으로 나눠질 수 있습니다. 이러한 작업은 서로 다른 고루틴으로 수행될 수 있습니다. 여러 고루틴을 사용하여 다른 작업을 수행하면 애플리케이션에서 동시성을 통한 애플리케이션 실행이 가능해집니다.

만약 이때 응용 프로그램이 여러 코어에서 실행 중인 경우 응용 프로그램에 병렬 처리도 추가합니다.

고루틴의 장점은 다음과 같습니다.

1. 가볍습니다.
2. 확장이 용이합니다.
3. 가상 쓰레드입니다.
4. 메모리 요구사항이 적습니다. (2KB)
5. 런타임 동안 고루틴에 추가 메모리를 제공합니다.

```go
package main

import (
	"fmt"
	"time"
)

func main () {
	start := time.Now()
	func() {
		for i:=0; i< 3; i++ {
			fmt.Println(i)
		} 
	}()

	elapsedTime = time.Since(start)

	fmt.Println("총 실행 시간: " + elapsedTime.String())

	time.Sleep(time.Second)
}
```

위의 코드는 Golang의 메인 함수 내에서 두 개의 자체 실행 함수를 순차적으로 실행합니다. 고루틴을 사용하지 않았으며, 동시성도 추가하지 않았습니다. 실행시 다음과 같은 출력을 얻습니다.

<a href="https://ibb.co/Hp3JzzQ"><img src="https://i.ibb.co/JFgh77P/README-md-Effective-Go.png" alt="README-md-Effective-Go" border="0"></a>

위의 프로그램은 메인 쓰레드에서 시작해서 메인 함수 내부에 존재하는 Go 함수를 실행한 다음, 내부에서 순차적으로 반복이 되는 형태로 구성이 되어 있습니다.

## Golang의 고루틴 소개

위의 시나리오에서는 메인 기능에 고루틴이 추가되지 않았습니다. 이때 실행하고자 하는 함수 앞에 `go` 키워드를 추가해서 Go 프로그램에 고루틴을 추가할 수 있습니다.

`go` 키워드를 추가하면, 고루틴을 통해 동시성을 추가할 수 있습니다. `go` 위의 실행에 키워드를 추가하면 다음과 같습니다.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	start := time.Now()
	go func () {
		for i := 0; i < 3; i++ {
			fmt.Println(i)
		}
	}()

	go func () {
		for i := -3; i < 0; i++ {
			fmt.Println(i)
		}
	}()

	elapsedTime := time.Since(start)
	fmt.Println("총 실행 시간: " + elapsedTime.String())

	time.Sleep(time.Second)
}
```

<a href="https://imgbb.com/"><img src="https://i.ibb.co/zPQJLRq/README-md-Effective-Go.png" alt="README-md-Effective-Go" border="0"></a>

위의 시나리오에서는 self-executing 되는 함수들에 `go` 키워드를 추가하고 있습니다.

실행은 메인함수에서 시작됩니다. `go` 키워드를 만나면 애플리케이션에 다른 `Go` 쓰레드를 추가하는 별도의 고루틴을 생성합니다. 이 쓰레드는 동시 쓰레드에서 함수를 실행하는 역할을 합니다.

그리고 유사하게, 두 번째 `go` 키워드를 만나면 다른 고루틴이 생성되며 이는 다른 고루틴 쓰레드 내에 존재하는 다른 self-executing 함수를 실행하게 됩니다.

이 시나리오에서는 총 세 개의 쓰레드가 동시성 모드에서 실행됩니다.
1. `main` 쓰레드 
2. `첫번째 sefl-executing 함수 실행` 쓰레드 
3. `두번째 sefl-executing 함수 실행` 쓰레드

## 순차 실행과의 차이점 이해

위 코드에서는 `go` 함수 실행 앞에 키워드를 추가했습니다. 키워드가 함수의 실행과 함께 추가되면 함수 실행을 위한 별도의 고루틴이 생성되고 해당 함수는 별도의 고루틴 쓰레드 내에서 실행됩니다.

위의 실행에서 볼 수 있듯 `go` 키워드를 함수 앞에 추가하면 동일한 쓰레드에서 실행되는 것이 아니라 실행을 위한 별도의 쓰레드가 생성되었습니다.

즉, 동시성이 추가되었고 이를 통한 성능 향상이 이뤄짐을 확인하였습니다.

## 병렬 처리 추가

![](https://miro.medium.com/max/700/1*mdrk8zl6ZmQuP5FdrRZxnQ.png)

Go에서는 다음과 같은 간단한 코드 라인으로 실행되는 코어를 추가할 수 있습니다.

```go
runetime.GOMAXPROCS(4)
```

해당 코드를 통해 애플리케이션이 여러 코어에서 확장되도록 지시할 수 있습니다. 여기에선 애플리케이션 실행을 위해 최대 총 4개의 코어가 사용될 수 있다고 지정했습니다.

고루틴을 생성하면 서로 다른 코어에서 함께 실행할 수 있으므로 병렬 처리가 가능해지고, 애플리케이션 속도가 빨라집니다.

```go
package main

import (
	"fmt"
	"runtime"
	"time"
)

func main() {
	runtime.GOMAXPROCS(4)
	start := time.Now()
	go func() {
		for i:=0; i < 3; i++ {
			fmt.Println(i)
		}
	}()

	go func() {
		for i:=10; i < 13; i++ {
			fmt.Println(i)
		}
	}()

	go func() {
		for i:=100; i < 103; i++ {
			fmt.Println(i)
		}
	}()

	go func() {
		for i:=1000; i < 1003; i++ {
			fmt.Println(i)
		}
	}()

	go func() {
		for i:=10000; i < 10003; i++ {
			fmt.Println(i)
		}
	}()

	go func() {
		for i:=100000; i < 100003; i++ {
			fmt.Println(i)
		}
	}()
	
	elapsedTime := time.Since(start)

	fmt.Println("총 실행 시간: " + elapsedTime.String())

	time.Sleep(time.Second)
}
```

프로그램이 여러 코어에서 병렬로 실행되었으며 더 빠른 실행이 가능해졌습니다.

실행 결과는 다음과 같습니다.

<a href="https://ibb.co/FVRD9wm"><img src="https://i.ibb.co/hf3mkWL/pararell-go-Effective-Go.png" alt="pararell-go-Effective-Go" border="0"></a>

코드의 `GOMAXPROCS`는 애플리케이션이 여러 코어에서 애플리케이션을 확장하도록 요청합니다.

이제 `go` 함수의 실행 앞에 해당 키워드를 추가하면 서로 다른 코어에서 별도로 실행되어 애플리케이션의 성능을 높일 수 있습니다.

동시성과 함께 병렬 처리가 이뤄진 모습입니다.

## 결론

앞선 여러 코드와 설명에서 보셨듯이 Golang에서 작업할 경우 애플리케이션을 동시 및 병렬 모드로 확장하는 것은 매우 용이합니다. `go` 함수에 키워드를 추가하기만 하면 애플리케이션 실행을 빠르게 확장할 수 있습니다.
