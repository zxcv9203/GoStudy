# 변수와 상수

> 변수

변수는 데이터가 저장되는 공간이며, Go는 변수를 `var` 라는 키워드를 사용해서 선언합니다.

`var` 키워드 뒤에 변수명을 적고, 그 뒤에 변수타입을 적습니다.

예를 들어, a라는 정수(int) 타입의 변수를 선언하려면 다음과 같습니다.

```go
var a int
```

변수 선언문에서는 변수를 초기화할 수 있습니다.

예를 들어, b라는 실수(float64) 타입의 변수에 10.5 라는 초기값을 할당하려면 다음과 같습니다.

```go
var b float64 = 10.5
```

그리고 한 번 선언된 변수는 다음과 같이 값을 할당할 수 있습니다.

```go
a = 10
b = 42.42
```

그리고 동일한 타입의 변수가 여러개 있을 경우 해당 변수들을 나열해서 선언할 수 도 있습니다.

```go
var c, d int
c, d = 24, 42
var e, f float64 = 0.42, 4.2
```

다음과 같이 변수를 `()` 안에 묶어서 여러개 선언할 수도 있습니다.

```go
var (
	myInt int
	myFloat float64
	myBool bool
	myString string
)
```

만약 선언과 동시에 값을 할당한다면 변수의 타입을 생략할 수 있으며, 이 때 변수의 타입을 할당한 값의 타입으로 자동 지정(타입 추론) 됩니다.

```go
var g = 3
fmt.Println(reflect.TypeOf(g), g) // int 출력
```

> 제로 값

Go에서는 값을 초기화하지 않으면 제로 값(zero value)을 할당합니다.

예를 들어, 숫자 형에는 0, bool 타입에는 false, string 타입에는 ""(빈문자열)을 할당합니다.

```go
package main

import "fmt"

func main() {
   var a int
   var b float64
   var c string
   var d bool

   fmt.Println("int의 제로 값 : ",a)
   fmt.Println("float64의 제로 값 : ",b)
   fmt.Println("string의 제로 값 : ",c)
   fmt.Println("bool의 제로 값 : ",d)
}

```

> 단축 변수 선언

다음과 같이 변수를 선언할 때 선언과 동시에 값을 할당할 수 있습니다.

```go
var n = 42                    // 변수 타입 자동 추론
var f float64 = 42.42         // 변수 타입 지정
```

변수를 선언할 때 선언과 동시에 값을 할당하는 경우에는 보통 단축 변수 선언(Short variable declaration)을 많이 사용합니다.

변수의 타입을 명시적으로 선언하고 나중에 값을 할당하는 대신 `:=` 연산자를 사용하면 더 간단하게 변수를 선언할 수 있습니다.

단축 변수 선언은 다음과 같이 선언합니다.

```go
myInt := 42
myFloat := 42.42
myString := "42"
myBool := true
```

단축 변수 선언을 사용하면 변수의 타입은 할당한 값의 타입으로 자동 지정되기 때문에 타입을 명시할 필요가 없습니다.

단축 변수 선언은 편리하고 간결하기 때문에 기본 변수 선언문보다 훨씬 더 자주 사용됩니다.

그럼에도 두 방식 모두 사용되기 때문에 두 방법 다 숙지하고 있어야 합니다.

> 재선언과 재할당(:=)

변수를 한 코드 블럭에서 여러번 할당하면 에러가 발생합니다.

```go
a := "abc"
a := "bbbb"       // error
```

하지만 Go에서 에러 처리를 하다보면 다음과 같이 에러처리를 할 때가 많습니다.

```go
f, err := os.Open(name)
if err != nil {
	log.Fatal(err)
}
d, err := f.ㄴtat()
if err != nil {
	log.Fatal(err)
}
```

위와 같이 작성해도 에러가 발생하지 않는 것을 확인할 수 있습니다.

이렇게 되면 `err` 변수가 중복선언되어 문제가 되는게 아닌가 생각이 들 수 있습니다.

하지만 이 선언은 문제가 없는데 `err` 은 첫 번째 구문을 통해서 선언되었지만 두번째에서는 재선언이 아닌 재할당이 됩니다.

즉, `f.Stat()`을 호출할 때 이미 선언되어 존재하는 `err` 변수를 사용하고, 다시 새로운 값을 부여한다는 것을 의미합니다.

변수의 단축 선언, `v :=` 에서 변수 v는 이미 선언되었더라도 다음의 경우 재선언이 가능합니다.

- 이 선언이 기존의 선언과 같은 스코프에 있어야 합니다. (만약 v가 이미 외부 스코프에 선언되었다면 새로운 변수 v를 만듭니다.)
- 초기화 표현내에서 상응하는 값은 v에 할당할 수 있어야 합니다.
- 적어도 하나 이상의 새로운 변수가 선언문 안에 함께 있어야 합니다.

이 독특한 속성은 실용적이며 연쇄적인 if - else 구문에서 하나의 에러 값을 쉽게 사용할 수 있게 해줍니다.

Go언어에서 함수 파라미터와 리턴 값들은 함수를 감싸고 있는 브래이스(braces) 밖에 위치해 있음에도 그 스코프는 함수 몸통의 스코프와 동일하다는 점을 주목해야 합니다.

> 상수

상수란 프로그램이 실행되는 동안 값이 고정되어 변경할 수 없는 메모리 공간을 의미합니다.

상수는 소스 코드에서 고정된 값을 체계적으로 관리하고 싶을 때 사용하며 반드시 선언과 동시에 초기화해야하며 선언한 뒤에는 값을 변경할 수 없습니다.

상수는 숫자, 문자, 문자열, 참/거짓 중 하나의 값이어야 합니다.

Go언어에서는 `const` 키워드를 사용하여 상수를 선언할 수 있습니다.

`const <name> <type> = <value>`의 형태로 선언하며 예시는 다음과 같습니다.

```go
const a int = 10
const s string = "hello"
```

Go의 타입 추론기능을 이용하여 타입을 생략해서 선언할 수도 있습니다.

```go
const c = 10
const s = "Hi"
```

여러개의 상수들을 묶어서 지정할 수 있는데, 아래와 같이 괄호 안에 상수들을 나열하여 사용할 수도 있습니다.

```go
const (
	a = 10
	b = "hello"
	c = 42.42
)
```

상수를 한줄에 묶어서 선언할 수도 있습니다.

```go
const a, b int = 42, 4242
```

Go에서는 열거형 상수를 iota 라는 열거자를 이용해서 생성합니다.

iota는 0부터 1씩 증가시킨 값을 할당 시켜줍니다.

```go
const (
	Apple = iota // 0
	Grape        // 1
	Orange       // 2
)
```